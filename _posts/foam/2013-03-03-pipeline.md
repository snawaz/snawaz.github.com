---
layout: foam
title: Pipeline
type: foamlibrary
description: A LINQ-like library for the most part, except that it supports composition in a way that LINQ does not.
permalink: /foam/pipeline.html
---

Pipeline is an incubation effort to mimic LINQ to a great extent, with few differences such as Pipeline supports composition in a way that LINQ doesn't, as a result of which you can *reuse* a query written in Pipeline for as many data source as you want. In LINQ, you cannot do that. 

Other differences arise from their semantics and the naming convention which is explained in the next section. Pipeline mixes quite well with [Expression][expression] library. In fact, they're so intertwined together that they are put in the same namespace called *foam::composition*.

###LINQ vis-a-vis Pipeline

Pipeline believes in calling a spade a spade. For example, Pipeline calls a filter *a filter*, whereas LINQ calls a filter [*a where*][where] due to reification of 
the idea of filtering. Likewise, Pipeline calls a transform a [*transform*][transform] instead of [Select][select] and [accumulate][accumulate] instead of 
[Aggregate][aggregate].

For example, consider this LINQ query,

{% highlight csharp %}
var names = participants                           //bind to source
           .Where(p => p.Age >= 13 && p.Age <= 19) //filtering
           .Select(p => p.Name)                    //transformation

//Or using query-operators
var names = from p in participants                //bind to source
            where p => p.Age >= 13 && p.Age <= 19 //filtering
            select p.Name                         //transformation
{% endhighlight %}

In this snippet, the query is bound to *persons*. If you want to do the same with another collection of person, then you've to write the whole query again. Pipeline avoids this problem by allowing you to compose different pieces of sub-query to form your query, **without** requiring you to bind the resulting query to 
a collection of entities. This enables *reuse*, because once you've your unbounded query, you can bind it to a collection of your choice later on. 

The equivalent of above LINQ query in Pipeline would be this,

{% highlight cpp %}
auto names =  from (participants)                                       //bind to source
            | filter([](person p) { return p.age >= 13 && p.age <=19 }) //filtering
            | transform([](person p) { return p.name.length(); } );     //transformation

auto names =  from (participants) | filter([](person p) { return p.age >= 13 && p.age <=19 }) | transform([](person p) { return p.name.length(); } );
{% endhighlight %}

Now after removing the *source* from the above query (i.e the *from* clause), what we're left with is, *reusuable* query, as it is **not** bound to any data source:

{% highlight cpp %}
auto query = filter([](person p) { return p.age >= 13 && p.age <=19 }) //filtering
           | transform([](person p) { return p.name.length(); }        //transformation
{% endhighlight %}

As we can see, there is no *participants* collection which the query is bounded to. So once we've this we can reuse it as:

{% highlight cpp %}
auto names1 = from(participants) | query; //bind to a collection, then execute the query.
auto names2 = from(students) | query;     //bind to a different collection and execute.
{% endhighlight %}

Pipeline is very flexible, so it comes with an alternative syntax : we can execute *query* as if it is a function! Here you go,

{% highlight cpp %}
auto names1 = query(participants);  //execute for participants
auto names2 = query(students);      //execute for students
{% endhighlight %}

#####Range vs Range

LINQ Range() creates a range of elements in the increasing order no matter what, so if you need a range of elements in the decreasing order, then you have to Reverse() it, as shown below:

{% highlight csharp %}
auto numbers = Enumerable.Range(2,12) //creates {2,3,4,5 ... 13} (12 elements)
                         .Reverse();  //returns {13,12,11 ... 2} (12 elements)
{% endhighlight %}

We'll soon see this in action, in this article itself.

[where]:http://msdn.microsoft.com/en-us/library/bb534803.aspx
[select]:http://msdn.microsoft.com/en-us/library/system.linq.enumerable.select.aspx
[aggregate]:http://msdn.microsoft.com/en-us/library/system.linq.enumerable.aggregate.aspx

[expression]: #beedu
[filter]: #beedu
[transform]: #beedu
[accumulate]: #beedu

###Deffered Execution

here you go.

###Pipeline + Expression = Elegance

{% highlight cpp%}
#include <foam/composition/pipeline.h> //include this header

using namespace foam::composition;

std::vector<int> v {1,2,3,4,5,6,7,8,9,10};

auto evens = from(v) | filter ( [](int i) { return i % 2 == 0; } ); //filter even integers

{% endhighlight %}
    
We could also use [Expression][expression] to make the code shorter as shown below::

{% highlight cpp%}
#include <foam/composition/expression.h> //include this to use expression

foam::composition::expression<int> x; //declare a variable!

auto evens = from(v) | filter(x % 2 == 0); //filter even integers

auto triples = from(v) | filter(x % 2 == 0) | transform(x * 3); //filter evens, then triple them.

for(int i : triples)               
   std::cout << i << " "; //prints 6 12 18 24 30

{% endhighlight %}


###Documentation

{% include JB/setup %}
{% assign allposts = site.posts %}
{% for post in allposts  %}
    {% if post.type == "pipelinedoc" %}
- [{{ post.title }}]({{ post.url }})   
    {% endif %}
{% endfor %}